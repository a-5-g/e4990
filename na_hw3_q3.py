# -*- coding: utf-8 -*-
"""na_hw3_q3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p0dQAdQVyJ4WwLVbY8iDn_6UFZrdrxc4
"""

import numpy as np
from numpy import linalg as LA

# Norm
def norm(x):
  return LA.norm(x,2)

# Gradient
def grad(x, A):
  return 2* (A@x)

# f(x)
def func(x, A):
  return x.T @ A @ x

def backtracking(x,A,alpha,beta,s,epsilon):
  iter = 0
  while(norm(grad(x,A)) > epsilon):
    iter = iter + 1
    t = s
    v1 = func(x,A) - func(x - t*grad(x,A), A)
    v2 = alpha * t * norm(grad(x,A))**2
    while(v1 < v2):
      t = beta * t
      v1 = func(x,A) - func(x - t*grad(x,A), A)
      v2 = alpha * t * norm(grad(x,A))**2
    x = x - t * grad(x,A)
  #print(iter, norm(grad(x,A)), func(x,A))
  return iter

def scaled_line(x,A,D,epsilon):
  iter = 0
  while(norm(grad(x,A)) > epsilon):
    iter = iter + 1
    num = grad(x,A).T @ D @ grad(x,A)
    den = 2 * (grad(x,A).T @ D.T) @ A @ (D @ grad(x,A))
    t = num/den
    x = x - t * (D @ grad(x,A))
    #print(iter, norm(grad(x,A)), func(x,A))
  return iter

def scaled_backtracking(x,A,alpha,beta,s,epsilon,D):
  iter = 0
  while(norm(grad(x,A)) > epsilon):
    iter = iter + 1
    t = s
    v1 = func(x,A) - func(x - t * (D @ grad(x,A)), A)
    v2 = alpha * t * (grad(x,A).T @ D @ grad(x,A))
    
    while(v1 < v2):
      t = beta * t
      v1 = func(x,A) - func(x - t * (D @ grad(x,A)), A)
      v2 = alpha * t * (grad(x,A).T @ D @ grad(x,A))
    x = x - t * (D @ grad(x,A))
  #print(iter, norm(grad(x,A)), func(x,A))
  return iter

s = 1
t = s
beta = 0.5
epsilon = 1e-4
x = np.array([1,2,3,4,5])
A = np.empty([5,5])
for i in range(0, 5):
  for j in range(0,5):
    A[i][j] = 1/(i+j+1)

"""### For part i)"""

alpha = 0.5
iter = backtracking(x, A, alpha, beta, s, epsilon)
print("Number of iterations required is:", iter)

"""### For part ii)"""

alpha = 0.1
iter = backtracking(x, A, alpha, beta, s, epsilon)
print("Number of iterations required is:", iter)

"""### For part iii)"""

D = np.zeros([5,5])
for i in range(0,5):
  D[i][i] = i+i+1

iter = scaled_line(x,A,D,epsilon)
print("Number of iterations required is:", iter)

"""### For part iv)"""

alpha = 0.1
iter = scaled_backtracking(x, A, alpha, beta, s, epsilon,D)
print("Number of iterations required is:", iter)

